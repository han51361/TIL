# CQRS 와 EventSourcing

CQRS는 네이밍에서 알 수 있듯이 명령과 쿼리의 역할을 구분 한다는 것이다. 
즉 커맨드`( Create - Insert, Update, Delete : 데이터를 변경)` 와 쿼리`( Select - Read : 데이터를 조회)`의 책임을 분리

### 탄생 배경
- 전통적인 CRUD 아키텍처 기반에서 Application을 개발 및 운영하다 보면 자연스레 Domain Model의 복잡도가 증가되기 마련
- 이로 인해 유지보수 Cost는 지속적으로 증가하게 되며 Domain Model은 점점 설계 시 의도한 방향과는 다르게 변질 되게 된다. 
- 특히나 요즘처럼 고차원적인 UX, 급변하는 Business, 시도때도 없이 달라지는 요구사항을 충족하는 Model을 만드는건 더욱 더 어려운일


이런 일련의 변경사항과 흐름을 곰곰히 관찰해 보니 Application의 Business정책이나 제약(흔히 비지니스 로직이라 부르는것들)은 거의 대 부분 데이터 변경 (C,U,D) 작업에서 처리되고 데이터 조회(R)작업은 단순 데이터 조회가 대 부분
- 이 두 업무를 동일한 Domain Model로 처리하게 되면 각 업무 영역에 필요치 않은 Domain 속성들로 인해 복잡도는 한 없이 증가
-  Domain Model은 애초 설계 의도와는 다른 방향으로 변질될 가능성이 높음 

> 해결방법 : 바로 명령을 처리하는 책임과 조회를 처리하는 책임을 분리 구현 -> CQRS 
> (사실 CQRS는 도메인 주도 개발 - DDD (Domain-driven design) 기반의 Object Model 방법론 적용시 나타났던 문제점들을 해결하기 위해 등장했다고 보는것이 보다 더 명확할 듯)

### 사용 방법

일반적 CRUD System 
![image](https://user-images.githubusercontent.com/27190617/210360635-c71ec71a-4f65-4809-92da-7994c50ad516.png)

전통적 계층에 CQRS 패턴 적용 방법 : 크게 3가지 방법 

### 1. 단일 Data Source에 command / Query 모델을 분리하는 방법

![image](https://user-images.githubusercontent.com/27190617/210360997-7013c909-7714-4fd1-a209-fefb7f939245.png)

- Database(RDBMS) 는 분리하지 않고 기존 구조 그대로 유지
- Model Layer 부분만 Command와 Query Model로 분리하는 수준으로 간단하게 적용. 
- 이렇게 분리된 Model은 각자의 Domain Layer에 대해서 만 모델링하고 코딩하기 때문에 훨씬 단순하게 구현/적용 가능. 
  - 하지만 동일 Database사용에 따른 성능상 문제점은 개선하지 못한다.

### 2. Command용 Database와 Query용 Database를 분리
![image](https://user-images.githubusercontent.com/27190617/210361202-3d7d550c-2c13-4db0-80c3-d742ed0fcec4.png)

- Command용 Database와 Query용 Database를 분리
- 별도의 Broker를 통해서 이 둘 간의 Data sync 처리 
- 해당 방식은 데이터를 조회 하려는 대상 서비스(시스템)들 : 각자 자신의 시스템(서비스)에 맞는 저장소를 선택 가능(폴리글랏 저장 구조)
>  폴리글랏 저장 구조 
>  (참고 : 다수의 Database 혼용하여 사용 하는 것을 폴리글랏 저장소 라고 함)로 구성 할 수 도 있다. 

-  이 경우 각각의 Model에 맞게 저장소(RDBMS, NoSql, Cache)를 튜닝하여 사용할 수 있다는 이점 
-  이는 1)일반 유형에서 거론된 동일 Database사용에 따른 성능 관점의 문제점을 해결 가능. 
-  하지만 동기화 처리를 위한 Broker의 가용성과 신뢰도 보장되어야 함 

### 3. Event Sourcing 적용 
![image](https://user-images.githubusercontent.com/27190617/210361647-615c1155-64e2-4588-9171-2b3efd01af16.png)

이벤트 소싱
- Application내의 모든 Activity를 이벤트로 전환해서 이벤트 스트림(Event Stream)을 별도의 Database에 저장하는 방식
- 이벤트 스트림을 저장하는 Database에는 오직 데이터 추가만 가능
- 계속적으로 쌓인 데이터를 구체화(Materialized)시키는 시점에서 그 때까지 구축된 데이터를 바탕으로 조회대상 데이터를 작성하는 방법을 말한다. 
 - Application내의 상태 변경을 이력으로 관리하는 패턴이 발전된 형태로 볼 수 있음 

`이벤트 소싱의 이벤트 스트림은 오직 추가만 가능하고` +  
`이를 필요로 하는 시점에서 구체화 단계를 거치게 되고`
= 이런 처리 구조가 CQRS의 Model분리 관점과 굉장히 궁합이 잘 맞기에 대부분 CQRS 패턴을 적용하고자 할 때 이벤트 소싱이 적용된 구조를 선택하게 된다.

> 주의) CQRS패턴에 이벤트 소싱은 필수가 아니지만 이벤트 소싱에 CQRS는 필수임


--- 
# Kafka와 (EventSourcing, CQRS)의 조화

### Event Sourcing Pattern
- 이벤트 소싱은 배치성 데이터 저장소에 현재 상태만 저장하는 것이 아니라 이벤트 브로커(전용 저장소)에 발생된 모든 이벤트 기록(레코드)들을 기록 
- 이를 통해 데이터 모델과 비즈니스 도메인을 동기화할 필요가 없어지고 성능, 확장성, 응답성이 향상되어 도메인 태스크를 간소화

 
- 기존에는 배치성 데이터 저장소(오라클, mysql 등)에 서비스에 들어오는 명령(또는 이벤트)이 발생할 때 마다 항상 동기화 처리  
  - 간단한 구조와 적은 데이터 접근만 일어날 때는 큰 이슈가 없지만, 데이터과 이벤트가 많아질 수록 데이터에 대한 CRUD와 같은 접근으로 인해 몇가지 이슈가 생길 수 있음.
 
**일반적인 CRUD System의 문제**
- CRUD시스템 : 데이터 저장소를 기준으로 작업을 수행하므로 성능, 응답속도가 저하되고 확장성이 제한될 수 있습니다.
- 많은 이벤트가 동시에 일어나서 데이터에 동시접근을 함으로서 트랜잭션 경합으로 인한 한계 발생
- 이벤트에 대한 기록을 하지 않고 데이터를 동기화 하므로 기록이 유실될 수 있음


이벤트 소싱 패턴 장점
- 발생한 이벤트를 백그라운드에서 실행할 수 있습니다. 그리고 트랜잭션 처리 중 경합이 발생하지 않으므로 서비스의 성능과 확장성이 높아집니다.
- 각 이벤트를 처리하는 서비스 애플리케이션들은 작은 단위의 로직
  - 이를 통해 구현과 관리를 간소화 할 수 있습니다.
- 직접 데이터 저장소의 데이터를 업데이트 하지 않아도 되기 때문에 동시 업데이트로 인한 충돌을 방지 가능 
- 언제든지 이벤트를 재실행(reprocess)하여 현재 상태를 다시 구현 가능 

 
주의점 
- 이벤트 소싱을 통해 발현된 데이터의 스키마가 변경될 수 있기 때문에 스키마 변경에 대한 버전 관리를 해야만 합니다. 
- 다중 스레드 애플리케이션과 여러 애플리케이션 인스턴스가 이벤트 브로커에 접근하기 때문에 이벤트 일관성에 대해 어떻게 처리할지 고민 필요 
  - 일관성 : 데이터 처리의 순서 또는 반드시 한번 처리(exactly-once)와 같은 내용이 포함됩니다.

> 이벤트 소싱과 이벤트 드리븐 아키텍처를 비교하기도 하는데 바라보는 아키텍처의 범위의 차이라고 이해해도 무방 
> 이벤트 소싱은 하나의 애플리케이션 또는 시스템 단위이고 이벤트 드리븐 아키텍처는 전체 시스템 또는 여러 애플리케이션을 연동하는 단위로 볼 수 있습니다.



### Kafka와 (EventSourcing, CQRS)의 조화

카프카 스트림즈 라이브러리를 사용하면 애플리케이션에서 이벤트 소싱 패턴과 CQRS 패턴을 구현 가능 

**Kafka Streams** 
- 카프카 클러스터와 연동할 수 있는 자바 라이브러리로서 토픽의 데이터를 처리(프로세스)하고 다시 토픽으로 데이터를 저장하는데 특화
- 추가적으로 토픽에 존재하는 스트림 데이터(또는 언바운디드 데이터, 끝이 없는 데이터)를 스트림단위, 테이블 단위로 조회하고 처리 가능 
- 카프카의 내부 구조(파티션 단위 등)에 맞게 동작하기 때문에 높은 확장성, 고 가용성, 분산처리 등의 특징을 지니고 있습니다.


**Application Using Kafka, Event Sourcing, CQRS**

1. 이벤트 소싱, CQRS로 구현된 애플리케이션들
![image](https://user-images.githubusercontent.com/27190617/210576754-1ddc0400-8edb-45bc-9bb2-6eee8c589743.png)

2. 위의 Event Handler를 Streams로 구현 
![image](https://user-images.githubusercontent.com/27190617/210577082-08eccae9-59ba-4c7c-8b1c-4bd2f0d6bd36.png)

3. 각각의 어플리케이션에서 구체화된 뷰를 개별적으로 생성 및 사용 -> 이벤트 소싱 패턴 및 CQRS 패턴 구현 
![image](https://user-images.githubusercontent.com/27190617/210577476-59fe00c6-f4c7-4bb2-8e37-d539a7824805.png)
![image](https://user-images.githubusercontent.com/27190617/210577624-ef47a0c9-6ffd-47b0-b60c-e821635ebcf6.png)


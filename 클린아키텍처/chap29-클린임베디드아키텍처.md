# chap29. 클린 임베디드 아키텍처 

소프트웨어는 닳지 않지만, 펌웨어와 하드웨어에 대한 의존성을 관리하지 않는다면, 안으로부터 파괴될 수 있다. 
- 하드웨어의 발전은 막을 수 없으므로, 임베디드 코드를 구조화할 수 있어야 함 
- 만약 코드에 sql을 심어 놓거나 개발하는 코드 전반에 플랫폼 의존성이 존재한다면, 본질적으로 그것은 소프트웨어가 아닌 펌웨어
- 펌웨어를 양산하는 일을 멈추고, 코드에게 유효 수명을 길게 늘릴 수 있는 기회를 주어야 함 

## 앱-티튜드 테스트 
- 앱이 동작하도록 만드는 것 : 앱티튜드 테스트 
- Kent Beck의 소프트웨어 구축하는 세가지 활동 
  - 먼저 동작하게 만들어라 
  - 그리고 올바르게 만들어라 (리팩터링 및 개선)
  - 그리고 빠르게 만들어라 (리팩터링을 통해 요구되는 성능을 만족시켜라)

## 타깃-하드웨어 병목현상 
특정 임베디드 장치에서만 테스트할 수 있다면 테스트 환경이 굉장히 국한적인 것 

### 클린 임베디드 아키텍처는 테스트하기 쉬운 임베디드 아키텍처
타깃-하드웨어 병목현상을 줄이는 방법 
- 계층 : (하단) 하드웨어 -> 펌웨어 -> 소프트웨어 
- 하드웨어는 시스템의 나머지 부분으로부터 반드시 분리되어야 함 
- 이 때 소프트웨어와 펌웨어가 서로 섞이는 일은 안티 패턴 
- 안티패턴시에, 변경하는 일 자체가 위험을 수반하고 또 의도치 않은 결과를 불러올 수 있음 
- 가벼운 변경에도 시스템 전체를 대상으로 회귀 테스트 전체 실행 

하드웨어는 세부사항이다. 
- 소프트웨어와 펌웨어의 경계를 정의하는 것은 대체로 힘듦
- 하지만 임베디드 소프트웨어 개발자가 해야 할 일은 이 경계를 분명하게 만드는 것 
- 소프트웨어와 펌웨어 사이의 경계 : 하드웨어 추상화 계층(HAL)

HAL 사용자에게 하드웨어 세부사항을 드러내선 안된다. 
- 만약 마이크로 컨트롤러를 사용할 때, 펌웨어가 저수준 함수들을 프로세서 추상화 계층(PAL)의 형태로 격리시켜 줄 수 있다. 
- 이를 통해 PAL 상위에 위치하는 펌웨어는 타깃-하드웨어에 관계없이 테스트 가능 및 덜 딱딱해짐

운영체제는 세부사항이다. 
- HAL은 필수적이지만, HAL 만으로 충분하지 않을 수 있다. 
- 만약 실시간 운영체제(RTOS)를 사용하거나, 임베디드 버전의 리눅스/윈도우를 사용한다면 이 때 코드의 수명을 늘리기 위해 운영체제를 세부사항으로 취급하고 운영체제에 의존하는 일을 막아야한다. 
- OS는 소프트웨어를 펌웨어로부터 분리하는 게층 
  - 계층 : (하단) 하드웨어 -> 펌웨어 -> OS -> 소프트웨어  
- 여기서도 마찬가지로 운영체제 추상화 계층 (OSAL)을 통해 소프트웨어를 운영체제로부터 격리 시킨다. 

### 인터페이스를 통하고 대체 가능성을 높이는 방향으로 프로그래밍하라
사실 모든 주요 계층 내부에서는 이 책에서 설명한 원칙들을 적용해야 한다. 
- 관심사 분리, 인터페이스 활용, 대체 가능성 높이는 방향으로 프로그래밍 
- 계층형 아키텍처는 인터페이스를 통해 프로그래밍하자는 발상을 기반으로 한다. 
- 인터페이스 정의는 헤더파일에 해야 한다. 하지만 헤더 파일에 무엇을 포함시킬 지는 신중하게 결정해야함 

### DRY : 조건부 컴파일 지시자를 반복하지 말라 


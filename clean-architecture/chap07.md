# 7장 SRP: 단일 책임 원칙

저자는 `SOLID` 원칙 중 가장 의미가 잘 전달되지 않은 원칙을 SRP라고 말한다.
이름 때문에 사람들은 모듈이 단 하나의 일만 해야한다는 의미로 받아들이기 쉽지만 해당 의미에 대해서는 클래스(모듈)가 아닌 함수에 적절한 의미이다
즉, 이 말은
- 단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.
- 하나의 모듈은 하나의, 오직 하나의 **액터**에 대해서만 책임져야 한다.

> 액터 : 변경을 요청하는 한 명 이상의 사람들
> 모듈 : 가장 단순한 정의(소스 파일)
> 코드를 소스 파일에 저장하지 않는 경우 모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합

`응집된(Cohesive)`이란 단어가 SRP를 암시하며 단일 액터를 책임지는 코드를 함께 묶어주는 힘

### 징후 1 : 우발적 중복
- 서로 다른 액터가 의존하는 코드를 너무 가까이 배치하면 문제가 생긴다.
- SRP는 **서로 다른 액터가 의존하는 코드를 서로 분리하라**고 말한다.

### 징루 2 : 병합
- 하나의 소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생한다.
- 병합을 할 때는 항상 위험이 뒤따른다
- **서로 다른 액터를 뒷받침하는 코드를 서로 분리**하여 병합 문제를 해결한다

### 해결책
- 가장 확실한 해결책 : 데이터와 메서드 분리하기
    - 서로의 존재를 모르고 따라서 `우연한 중복`을 피할 수 있다.
    - 하지만 이는 각 클래스를 인스턴스화하고 추적해야한다는 단점도 같이 존재
    - 위 문제를 해결하는 기법 **퍼사드(Facade)**패턴
- 가장 중요한 메서드만 유지, 그 클래스를 덜 중요한 메서드들에 대한 퍼사드로 사용 가능

### 결론
- 단일 책임 원칙은 객체지향에서의 메서드와 클래스 수준의 원칙
- 상위 수준에서는 다른 형태로 존재
    - 컴포넌트 수준 : 공통폐쇄원칙(Common Closure Principle)
    - 아키텍처 수준 : 아키텍처 경계(Architectural Boundary)의 생성을 책임지는 변경의 축(Axis of Change)

# 8장. 분산시스템의 골칫거리

### **신뢰성과 관련하여**

**서로의 노드가 서로를 믿지 못한다.** 

**신뢰성?**

> **그렇다면 왜 HTTP3 는 신뢰성없는 UDP를 선택한 이유는 무엇일까 
HTTP3가 UDP를 선택한 배경과 이점에 대해 알아보자**


![image](https://user-images.githubusercontent.com/27190617/203788416-697f4e61-a3e1-443d-860e-d510c7ea8cb3.png)


**`HTTP/3`  :**  **`HTTP(Hypertext Transfer Protocol)`**의 세 번째 메이저 버전

- 기존의 HTTP/1, HTTP/2와는 달리 UDP 기반의 프로토콜인 **`QUIC`**을 사용하는 통신하는 프로토콜
    - **`QUIC : Quick UDP Internet Connection`**
     말 그대로 UDP를 사용하여 인터넷 연결을 하는 프로토콜
- HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신

### TCP vs UDP
![image](https://user-images.githubusercontent.com/27190617/203788445-b167b624-5aa2-432f-ba01-0ca518ffee20.png)

### 배경

- HTTP/2 점유율을 보면 40%

![image](https://user-images.githubusercontent.com/27190617/203788524-527d440f-09cf-4b56-b414-b0a54622ae71.png)
- HTTP/2 가 나온지 4년만에 HTTP/3 출시

**TCP**의 **3 Way Handshake & 4 Way Handshake**

![image](https://user-images.githubusercontent.com/27190617/203788541-3b32a449-f5d1-4eca-9d93-e51c4d8a09e5.png)
- 클라이언트가 처음 서버와 통신을 하기 위해 TCP 연결을 생성할 때 **`SYN`**와 **`ACK`**
이라는 패킷을 주고 받음.
- 이 패킷 내부에 들어있는 값들을 사용하여 클라이언트와 서버가 서로 보낸 패킷의 순서와 패킷을 제대로 받았는지를 확인 가능
- 연결을 끊을 때 :  마찬가지로 4회의 handshake 발생

> **즉, TCP를 사용하는 이상 본격적인 통신을 시작하기 전에 무조건 저 번거로운 통신 과정을 거쳐야한다**

HTTP/1에서 HTTP/2로 넘어갈 때도 핸드쉐이크 과정 자체는 건드리지 않고, 
**단지 핸드쉐이크가 발생하는 횟수를 최소화함으로써 레이턴시를 줄임**
이는 TCP를 사용하는 이상 핸드쉐이크가 반드시 필요한 과정이기 때문에 건드리지 못한 것이다.

HTTP/3는 UDP를 사용함으로써 **이 핸드쉐이크 과정 자체를 날려버리고** 
다른 방법으로 연결의 신뢰성을 확보함으로써 레이턴시를 줄이는 방법을 택했다.
> 

### 또다른 TCP 의 문제점 : HOLB

**HOLB** : **Head of line Blocking**

<aside>
💡 TCP 통신은 패킷이 처리되는 순서 또한 정해져있으므로 
이전에 받은 패킷을 파싱하기 전까지는 다음 패킷을 처리할 수도 없다. 

→  패킷이 중간에 유실되거나 수신 측의 패킷 파싱 속도가 느리다면 통신에 병목이 발생하게 되는 현상

</aside>

- TCP를 사용한 통신에서 패킷은 무조건 정확한 순서대로 처리
    - 수신 측은 송신 측과 주고받은 시퀀스 번호를 참고하여 패킷을 재조립해야하기 때문
- 사실 HTTP 레벨에서의 HOLB와 TCP 레벨에서의 HOLB는 다른 의미이기는 하나 결국 어떤 요청에 병목이 생겨서 전체적인 레이턴시가 늘어난다는 맥락으로 본다면 동일

---

### UDP 를 통한 방법과 이점

UDP : User Datagram Protocol

- UDP는 데이터 전송 자체에만 초점을 맞추고 설계되었기 때문에 헤더에 진짜 아무 것도 없다.
- UDP의 헤더에는 출발지와 도착지, 패킷의 길이, 체크섬 밖에 없다.
- 따라서 헤더에는 다양한 정보를 담을 수 있는 **커스터마이징이 충분히 가능하다**

![image](https://user-images.githubusercontent.com/27190617/203788578-fbeafdc8-8bfd-4e6f-9dc0-077d701dd129.png)

**TCP : 헤더가 이미 그득그득**

![image](https://user-images.githubusercontent.com/27190617/203788610-a4b15edc-b5c2-4d28-b271-0358a5e353a0.png)

물론 TCP가 신뢰성을 확보하기 위하여 다양한 기능을 담고 있어, 개발자의 입장에서는 편리하지만, 
필수적으로 사용해야할 기능들이 아니라면, 무거운 단점으로…

`TCP : **좋은 기능이 다 들어있는 무거운 라이브러리 / UDP : 필요한 기능만 들어있는 가벼운 라이브러리**`

기존 **HTTP + TLS + TCP** 

![image](https://user-images.githubusercontent.com/27190617/203788668-42fe41bc-0f46-4c2f-a91a-02f922df7c75.png)


**HTTP/3** : **`QUIC`**을 기반으로 돌아가는 프로토콜

- QUIC :  구글이 개발
    - TCP가 가지고 있는 이런 문제들을 해결하고 레이턴시의 한계를 뛰어넘기위한  UDP 기반의 프로토콜
    - 처음부터 TCP의 핸드쉐이크 과정을 최적화하는 것에 초점을 맞추어 설계

---

## 이점

### **연결 설정 시 레이턴시 감소**

QUIC:  TCP를 사용하지 않기 때문에 통신을 시작할 때 번거로운 3 Way Handshake 과정을 거치지 않아도 된다. 

**`RTT(Round Trip Time)` :** 클라이언트가 보낸 요청을 서버가 처리한 후 다시 클라이언트로 응답해주는 사이클 

- TCP : 연결을 생성하기 위해 기본적으로 **`1 RTT`** 여기에 TLS를 사용한 암호화까지 하려고 한다면 TLS의 자체 핸드쉐이크까지 더해져 총 **`3 RTT`**가 필요
- QUIC : 첫 연결 설정에 **`1 RTT`**만 소요.
    - 클라이언트가 서버에 어떤 신호를 한번 주고, 서버도 거기에 응답하기만 하면 바로 본 통신을 시작할 수 있다는 것이다. 
    → 즉, 연결 설정에 소요되는 시간이 반 정도 밖에 안된다.

![image](https://user-images.githubusercontent.com/27190617/203788722-2beda91b-a393-499c-a2d8-a9b6fa5718b8.png)

<aside>
💡 **원리** : 
첫번째 핸드쉐이크를 거칠 때, 연결 설정에 필요한 정보와 함께 데이터도 보내버리는 것이다. 

**`TCP+TLS :`** 데이터를 보내기 전에 신뢰성있는 연결과 암호화에 필요한 모든 정보를 교환하고 유효성을 검사한 뒤에 데이터를 교환

`**QUIC**` : 묻지도 따지지도 않고 그냥 바로 데이터부터 꽂아버리고 시작

단, 클라이언트가 서버로 첫 요청을 보낼 때는 서버의 세션 키를 모르는 상태이기 때문에 목적지인 서버의 Connection ID를 사용하여 생성한 특별한 키인 **`초기화 키(Initial Key)`**
를 사용하여 통신을 암호화

그리고 한번 연결에 성공했다면 서버는 그 설정을 캐싱, 
다음 연결 때는 캐싱해놓은 설정을 사용하여 바로 연결을 성립 
→  **`0 RTT`**으로 바로 통신 가능

</aside>

---

### 패킷 손실 감지 시간 단축

QUIC도 TCP와 마찬가지로 전송하는 패킷에 대한 흐름 제어를 해야한다. 
왜냐면 QUIC, TCP 모두 결국 본질적으로는 **`ARQ`**방식을 사용하는 프로토콜

**TCP** : **`Stop&Wait ARQ`**

- 패킷 손실 감지를 위해 “타임아웃을 언제 발생시킬 것인가” → 동적 계산 필요
- 이 때의 시간 = `**RTO(Retransmission Time Out)`**
    - RTO를 위해 필요한 것이 `RTT`
    - 하지만 패킷 손실이 낫을 경우에는 RTT의 계산이 어려워진다.


> 💡 만약 패킷 전송 -> 타임 아웃 -> 패킷 재전송 -> ACK 받음! 와 같은 상황 발생
> → (근데 이거 첫 번째로 보낸 패킷의 ACK야? 두 번째로 보낸 패킷의 ACK야?) 
> = 재전송 모호성

이러한 문제를 위해 타임스탬프를 패킷별로 찍어주는 또 다른 방법 요구 + 패킷 검사 필요 

> `Stop&Wait ARQ` : 
송신 측이 패킷을 보낸 후 타이머를 사용하여 시간을 재고, 
일정 시간이 경과해도 수신 측이 적절한 답변을 주지 않는다면 패킷이 손실된 것으로 판단하고 해당 패킷을 다시 보내는 방식**
 

**QUIC** 

- 헤더에 별도의 패킷 번호 공간 부여
- 해당 패킷 번호는 오로지 전송 순서만 나타내고, 재전송에도 다른 순서가 부여된다. 따라서 전송 순서를 명확히 파악 가능
- 이를 통해 손실 감지 시간을 줄일 수 있음

---

### 클라이언트의 IP가 바뀌어도 연결이 유지된다.

- TCP
    - 소스의 IP 주소와 포트, 연결 대상의 IP 주소와 포트로 연결을 식별하기 때문에 클라이언트의 IP가 바뀌는 상황이 발생하면 연결이 끊어져 버린다.
    - 결국 다시 연결을 위해 핸드쉐이킹 필요 → 레이턴시
    - 더불어 모바일의 경우 : wifi , 셀룰러 변환 잦음
- QUIC
    - Connection ID를 사용하여 서버와 연결을 생성한다.
    - Connection ID는 랜덤한 값일 뿐, 클라이언트의 IP와는 전혀 무관한 데이터이기 때문에 클라이언트의 IP가 변경되더라도 기존의 연결을 계속 유지할 수 있다.
    - 이는 새로 연결을 생성할 때 거쳐야하는 핸드쉐이크 과정을 생략할 수 있다는 의미이다.
